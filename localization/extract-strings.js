const fs = require('fs');
const DEBUG = false;

const HtmlWebpackPlugin = require('html-webpack-plugin');
const crypto = require('crypto');

function readJSON() {
  try {
    return JSON.parse(
      fs.readFileSync(`./localization/locStrings.json`, 'utf8'),
    );
  } catch {
    /* file not found or corrupted */
    return {};
  }
}

function readHTML(compiler) {
  const { outputPath } = compiler;
  const indexHtmlPath = outputPath + '/index.html';
  return fs.readFileSync(indexHtmlPath, 'utf8');
}

function writeJSON(registry) {
  const locFileJSON = JSON.stringify(registry, Object.keys(registry).sort(), 4);
  fs.writeFileSync(`./localization/locStrings.json`, locFileJSON);
}

function generateJS(registry, locales) {
  const locFileJSON = JSON.stringify(registry, Object.keys(registry).sort(), 4);
  const localesJSON = JSON.stringify(locales, null, 4);
  const content = `
/* --- AUTOGENERATED --- */
const LOCALIZED_STRINGS = ${locFileJSON};
const LOCALIZED_TARGETS = ${localesJSON};`;
  return content;
}

const attributeMap = {
  'data-localize-text': 'innerHTML',
  'data-localize-content': 'content',
  'data-localize-aria': 'aria-label',
};

function extractNodeString(node, attribute) {
  const targetAttributeName = attributeMap[attribute];
  return targetAttributeName == 'innerHTML'
    ? node.innerHTML.trim()
    : node.getAttribute(targetAttributeName).trim();
}

function extractSourceStrings(dom) {
  const sourceStrings = {};

  function extractAttribute(attribute, innerHtml) {
    dom.window.document.querySelectorAll(`[${attribute}]`).forEach((node) => {
      const locStr = extractNodeString(node, attribute);
      sourceStrings[hashString(locStr)] = locStr;
    });
  }
  extractAttribute('data-localize-text', true);
  extractAttribute('data-localize-content', false);
  extractAttribute('data-localize-aria', false);

  return sourceStrings;
}

function mergeSourceStrings(sourceStrings, oldStrings, locales, baseLocale) {
  const baseSourceStrings = Object.fromEntries(
    Object.entries(sourceStrings).map(([k, v]) => [k + ':' + baseLocale, v]),
  );

  const placeholders = {};
  locales.forEach((locale) => {
    Object.assign(
      placeholders,
      Object.fromEntries(
        Object.entries(sourceStrings).map(([k, v]) => [
          k + ':' + locale,
          '---TODO---',
        ]),
      ),
    );
  });

  return Object.assign({}, placeholders, oldStrings, baseSourceStrings);
}

function hashString(str) {
  const clean = str.replace('Â ', ' ').replace('&nbsp;', ' ');
  return crypto.createHash('sha256').update(clean).digest('hex').slice(0, 8);
}

function hashDom(dom) {
  function hashAttribute(attribute, innerHtml) {
    dom.window.document.querySelectorAll(`[${attribute}]`).forEach((node) => {
      const locStr = extractNodeString(node, attribute);
      node.setAttribute(attribute, hashString(locStr));
    });
  }
  hashAttribute('data-localize-text');
  hashAttribute('data-localize-content');
  hashAttribute('data-localize-aria');
}

function createDom(domString) {
  const jsdom = require('jsdom');
  const dom = new jsdom.JSDOM(domString);
  return dom;
}

class ExtractLocStrings {
  constructor(options) {
    this.baseLocale = 'en-US';
    this.locales = options.locales;
    if (options.locales.length == 0) {
      this.baseLocale = options.locales[0];
    }
  }

  apply(compiler) {
    const { webpack } = compiler;
    const { RawSource } = webpack.sources;

    compiler.hooks.compilation.tap('ExtractLocStrings', (compilation) => {
      compilation.hooks.optimizeAssets.tapAsync(
        'ModifyHtmlPlugin',
        async (data, callback) => {
          // extract strings, write json base.
          try {
            const htmlContent = readHTML(compiler);
            const htmlDom = createDom(htmlContent);
            const jsonStrings = readJSON();
            const sourceStrings = extractSourceStrings(htmlDom);
            const registry = mergeSourceStrings(
              sourceStrings,
              jsonStrings,
              this.locales,
              this.baseLocale,
            );
            writeJSON(registry);
            DEBUG && console.log('---Extract strings---');
            DEBUG &&
              console.log(
                ' - ',
                Object.keys(registry).length + ' entries extracted',
              );
          } catch (error) {
            console.error('Could not load js', error);
          }
          callback(null, data);
        },
      );
      HtmlWebpackPlugin.getHooks(compilation).alterAssetTags.tapAsync(
        'ExtractLocString',
        (data, callback) => {
          // read json registry, generate + append js script to head
          const jsonStrings = readJSON();
          const content = generateJS(jsonStrings, this.locales);
          const hash = hashString(content);
          const filename = `localization-${hash}.js`;

          compilation.emitAsset(filename, new RawSource(content));

          data.assetTags.scripts.push({
            tagName: 'script',
            voidTag: false,
            meta: { plugin: 'html-webpack-plugin' },
            attributes: {
              src: `${filename}`,
              defer: true,
            },
          }),
            callback(null, data);
        },
      );

      HtmlWebpackPlugin.getHooks(compilation).afterTemplateExecution.tapAsync(
        'ExtractLocString',
        (data, callback) => {
          // inject html tags with hashes
          const htmlDom = createDom(data.html);
          hashDom(htmlDom);
          data.html = htmlDom.serialize();
          callback(null, data);
        },
      );
    });
  }
}

module.exports = ExtractLocStrings;
